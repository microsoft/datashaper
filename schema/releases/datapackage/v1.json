{
	"$schema": "http://json-schema.org/draft-07/schema#",
	"definitions": {
		"Resource": {
			"description": "Parent class for any resource type understood by the system.\nAny object type that extends from Resouce is expected to have a standalone schema published.\nFor project state, this can be left as generic as possible for now.",
			"properties": {
				"$schema": {
					"type": "string"
				},
				"description": {
					"description": "Description of the named resource.",
					"type": "string"
				},
				"homepage": {
					"description": "URL to a public webpage that describes this resource.",
					"type": "string"
				},
				"license": {
					"description": "SPDX license string.\nhttps://spdx.org/licenses/",
					"type": "string"
				},
				"name": {
					"description": "User-specified name. This will serve as the local id (i.e., like a filename.) and should be URI-compatible.\nThis should be editable, just like any other filename on a file system.",
					"type": "string"
				},
				"path": {
					"anyOf": [
						{
							"items": {
								"type": "string"
							},
							"type": "array"
						},
						{
							"type": "string"
						}
					],
					"description": "URI-compliant path to the resource (local or remote).\nIf array-valued, this points to a list of files that comprise the dataset (e.g., for splitting very large tables).\nTODO: frictionless also includes a pathType indicating if a file is local or remote. Is this needed?"
				},
				"profile": {
					"description": "Defines the resource type.\nKnown resource types should have accommpanying processors and rendering components.\nUnknown resource types can be interrogated to determine if the format is understandable by an existing component.\nNote that this could be inferred from $schema, but a simple string here is easier to deal with in code.",
					"type": "string"
				},
				"sources": {
					"description": "List of resources that underly this resource.\nThis gives us the ability to create hierarchical or linked structures\nto represent complex combinations.\nFor example, a parent resource can have source tables, a workflow, and a table schema that all combine\nto create a fully-realized, strongly typed, and transformed output table.\nTODO: should this be a direct Resource list, or should each entry be a container object that also defines the relationship?\n\nTODO: linking is a little cumbersome. It seems that a Resource should be linkable with _just_ a URL - including core required properties is redundant.\nunderstanding-json-schema/structuring.html#json-pointer) to a subschema?",
					"items": {
						"$ref": "#/definitions/Resource"
					},
					"type": "array"
				},
				"title": {
					"description": "Friendly name of the resource. Used for display only.",
					"type": "string"
				}
			},
			"type": "object"
		}
	},
	"description": "Defines a Data Package, which is a collection of data resources\nsuch as files and schemas.\nLoosely based on the Frictionless spec, but modified where needed to meet our needs.\nhttps://specs.frictionlessdata.io/data-package/",
	"properties": {
		"$schema": {
			"type": "string"
		},
		"description": {
			"description": "Description of the named resource.",
			"type": "string"
		},
		"name": {
			"description": "User-specified name. This will serve as the local id (i.e., like a filename.) and should be URI-compatible.\nThis should be editable, just like any other filename on a file system.",
			"type": "string"
		},
		"resources": {
			"items": {
				"$ref": "#/definitions/Resource"
			},
			"type": "array"
		},
		"title": {
			"description": "Friendly name of the resource. Used for display only.",
			"type": "string"
		}
	},
	"type": "object"
}
